# TLLprotocol 电信连接语言系统

TLL： Telecom Linked Language

作者尽量在既不影响脚本之间的插拔和其他功能运作、保证安全和有序的同时，最小化网络之间的传播负荷和延迟，并且免去不同语言之间频繁转译的问题而诞生此协议。

## 这个系统有什么好处？
- 我们只包含了6个字段，直接发送抽象描述api的方法直接或间接控制脚本的运行。
- 可以提供描述话语或者需求，即可直接控制对象
- 安全高效的安全鉴定方法
- 便携加入和退出脚本，可以允许不同脚本间互相联系和调用。
- 因为此协议只要求用户提供方法接口，所以理论上是个脚本就能接进来。

## 这个系统的缺陷在哪里？
- 由于现在智能体技术尚未成熟，本协议牺牲了交互时间来换取稳定的方法控制。
- 协议处于早期，只能说能用，但是仍然偶尔会产生消息丢失的情况。对用户体验并不是很好
- 没有前端交互界面。看着很单调
- 本协议做的时间有点滞后。同期相关智能体项目有的早就发展一年了，然而本协议仅仅诞生一个月。

> TLL协议 是一种利用机器人之间交流协作而实现Agent智能的方式。其本质是通过网络进行任务分发和调配。
> 协议简单，部署方便，理论上任何的脚本/api都可以通过此协议实现智能化

> 适用场景：物联网应用：如智能家居、智慧城市、智能陪伴伙伴等；人工智能对话、助理、邮件收发，点歌，控制电脑，游戏陪玩...你想干什么，接进来就行。

通过TLL协议，你对任何想要智能化的脚本要做的唯一动作就是 把api配置进来。剩下的，交给大语言模型吧。

> Generator 单子叶蚕豆

# 快速入门
## 部署
### 电脑端部署
如果你使用的api对应电脑端python，建议python版本不低于3.8。

本协议暂时使用百度语音转写和openai协议，请安装下面的包：

```shell
pip install PyAudio==0.2.11
pip install openai==1.59.8
pip install baidu-aip==4.16.13
pip install pygame==2.6.1
```
将代码包安装，放在项目根目录下即可

### esp32+micropython 部署

STM32LisTLLProtocol包 是在esp32单片机上运行测试的包，能够正常使用。使用时请将固件升级至至少1.20版本。

## 使用方法
### 前置术语
> 环境： 你的所有机器人的集合

> 组： 你的机器人可能会分成不同类型，具有不同权限。权限相同的机器人称为一组

> 主动感知： 你的机器人会检测你的活动状态，并主动给你发消息

### 基础信息
首先，你需要给自己的这个机器人起一个名称，给你起一个用户名，并且确定他是否具有麦克风、扬声器等硬件。然后配置以下参数。
从包中导入 LisTLLProtocol类 实例化后开始修改参数。
```python
from LIS_Bot_method.LisTLLProtocol import LisTLLProtocol, LinguisticCore
realize = LisTLLProtocol()
```

然后，请你为机器人确定一个组别（level），这用于让机器人之间分离群体。


### 基础参数
由于本协议采用mqtt的传输方式，请确保你接入了互联网，或者你的mqtt服务器。

下面以SaYi_SV配置文件为例

| 参数名         | 类型     | 描述                  | 示例                    |
|-------------|--------|---------------------|-----------------------|
| name        | string | 你的机器人名称             | "SaYi_SV"             |
| user        | string | 你的用户名               | "单子叶蚕豆"               |
| description | string | 机器人功能描述             | "SaYi_SV,所有家庭机器人的中枢。" |
| tll_port    | int    | 机器人交流用Topic id      | 8040                  |
| nlp_port    | int    | 机器人语义理解与处理用Topic id | 8041                  |
| tsk_port    | int    | 机器人与用户对话用Topic id   | 8042                  |
| cyber_pos   | string | 机器人mqtt服务器url       | 'test'                |
| cyber_port  | int    | mqtt服务器端口           | 1883                  |

### 方法设置
由于不同场景下的机器人需要不同的能力，例如 
允许语音、允许发音、允许机器人调度机器人等。因此需要配置以下几个bool类型参数


| 参数名                   | 描述            | 建议                                   |
|-----------------------|---------------|--------------------------------------|
| speak_access          | 允许机器人以扬声器输出结果 | 有条件True，没有条件False                    |
| listen_access         | 允许用户语音输入      | 有条件True，没有条件False                    |
| spare_access          | 允许机器人智能感知 *   | 机器人作为陪伴或助理时True                      |
| front_linguistic_mode | 用户直控模式 *      | 需要用户直接调用时True                        |
| llm_linguistic_mode   | 模型直控模式 *      | 需要模型解析你的语言后执行时True,和上面的不冲突           |
| voice_filter          | 错误语音输入过滤器 *   | 语音环境不好时True，但会增加些许延迟                 |
| command_arg           | 允许关键词通行 *     | 直接通过关键词执行，设置为True可以大幅度减少延迟，但是会降低对话体验 |

其中，* 代指的所有功能你可以在**特殊机器人和特殊配置**找到对应解释
### api接入
机器人的功能需要管理员手动经过以下几个配置来挂载在协议上提供服务。

请确保你有相关功能的接口。例如，点亮灯泡，你应该拥有这个功能的对应函数。（不会有人写代码不封装成方法吧lol）

#### command_list 命令表
命令表是一个字典，用于将对应控制词和api连接的表单。例如，现在有一个启动功能(start)和一个发送消息功能(send),则命令表应该声明成：

注意： 所有参数以一个列表传入，你的api应该只接受一个参数，并在函数体内对列表进行参数的拆分。
```python
    # key：控制词  value：函数名
    command_list = {
            "start": start,
            "send": send
        }
```

#### permission_list 鉴权表
鉴权表用于避免一些功能被不该允许调用的机器人调用。假如你仍然有上述功能，则设置方法如下。
```python
realize.permission_list = {
    # key：控制词  value：权限
    "start": "name=DzyCd,level=3",
    "send": "name=SaYi_SV"
}
```
其中权限的设置格式：

| 名称    | 含义            | 例子      |
|-------|---------------|---------|
| name  | 将指定名字的机器人设置白名单 | name=SaYi_SV |
| level | 将指定组的机器人设置白名单 | level=2 |

如果你想设置多个白名单，请用,分割字符串
"name=DzyCd, level=1, name=SaYi_SV"

#### (可选) 函数理解方法 translate
此功能调用deepseek 的 function_calling 方法来生成函数。请根据官方tools配置方法来配置此变量。

```python
translate = [{
                "type": "function",
                "function": {
                    "name": "start",  # 函数名
                    "description": "打开监控",  # 对函数功能的描述
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "name": {  # 参数名
                                "type": "string",
                                # 描述参数的作用
                                "description": f"这是一个例子，返回None就可以",
                            }
                        },
                        "required": ['name']  # 把所有声明参数放进来，按照格式分好
                    },
                }
            },
            {"type": "function", "function": {
                    "name": "send",
                    "description": "发送数据",
                    "parameters": {
                        "type": "object",
                        "properties": {
                        },
                        "required": []
                    },
                }
            }
        ]
```
#### 注册表 access_list
注册表用于注册你的所有机器人，确保他们拥有合适的权限、功能和调用方法。如果你拥有一个中枢机器人（SaYi_SV），则只需要在此配置你当前机器人的权限表和SaYi_SV的信息，再在SaYi_SV的权限表中配置当前机器人的权限表即可。
如果你没有SaYi_SV中枢，则需要在环境中所有机器人中配置此机器人的权限表。

Key：你的机器人名称

Value：一个字典：

| 名称        | 类型     | 描述                      | 示例              |
|-----------|--------|-------------------------|-----------------|
| level     | int    | 机器人分组                   | 1               |
| cyber_pos | string | 机器人的mqtt地址              | test            |
| real_pos  | string | 机器人的实际地址（保留字段）          | China           |
| tll_port  | int    | 此机器人用于机器人通讯的的tll_port   | 8081            |
| introduce | string | 机器人功能介绍                 | 所有家庭机器人的中枢      |
| command   | dict   | 关键词注册。需要使用的关键词和相应命令表控制词 | {'启动': 'open'}  |

```python
access_list = {
    "SaYi_SV": {"level": 2, "cyber_pos": 'zebbb810.ala.dedicated.aliyun.emqxcloud.cn', "real_pos": "None", "tll_port": 8040,
                "introduce": "所有家庭机器人的中枢。", "command": {}},
    "SaYi_900": {"level": 1, "cyber_pos": 'zebbb810.ala.dedicated.aliyun.emqxcloud.cn', "real_pos": "None", "tll_port": 8050,
                "introduce": "可以控制电脑端的应用软件", "command": {'启动': 'open'}}
}
```

到此，你已经完成了对机器人的所有运行文件配置。

# 特殊机器人及特殊配置
## SaYi_SV 中枢机器人
中枢机器人固定名字SaYi_SV。如果你想配置一个机器人直接管理注册表和其他机器人的网络活动，请设置她的名字为SaYi_SV

一旦SaYi_SV配置完成，其他机器人启动时会向SaYi_SV申请权限表。此时用户应该在command_list中配置一个注册名为get的方法。

你可以直接使用以下代码
```python
def get(arg):
    if arg[0] == 'access_list':
        time.sleep(3)
        return "202+" + f"dos+access_update({str(realize.access_list)})"
    else:
        return "503"
```
## 允许了模型直控模式（llm_linguistic_mode）的机器人
模型直控模式通过识别模型返回参数中‘【发送通知】’标签来作出决定。在设置此项为True时，你可能需要编写语言核心，让机器人能够正确输出【发送通知】标签。

模型要求在此标签后提出控制要求

```
模型输出： 主人。如果有其他需求，请随时告诉我。【发送通知】通知SaYi_992开启QQ应用。

控制台输出： INFO: 机器人触发TLL标签：通知SaYi_992开启QQ应用。

用户端输出： 主人。如果有其他需求，请随时告诉我。
```
## 错误语音输入过滤器
此功能机器人会持续接收语音输入，如果你并不在跟机器人对话，但是语音输入产生结果，可以开启此功能来过滤非正常的输入

缺点：需要经过一层文本分析

## 允许机器人智能感知
智能感知会让机器人在你有其他活动或闲置一段时间后主动跟你聊天生成语言。

缺点：需要多开一个线程

## 用户直控模式
用户可以通过语音直接控制机器人。

缺点：会经过一层文本分析

## 允许关键词通行
用户可以通过输入前置关键词来直接控制其他机器人。此功能触发时，会自动匹配所有符合条件的关键词并发送控制消息。
并将除去前缀的文本作为参数输入，并阻止此关键词进行语义理解。这可以大幅度省去控制延时时间。（大约减90%）

缺点：此关键词为前缀的所有文本都无法进行进一步的分析。

# 扩展核心

## 扩展-语言核心Linguistic_Core
此模块是用于对机器人角色扮演的配置文件。你可以在此配置机器人的身份、性格特征，供LLM处理和扮演。

### 前置准备
请确定你的机器人名称，你的名称。最好和上面的配置一样。

导入包中的Linguistic_Core。

### 身份设置 profile
在此，写入你的机器人的基本信息。

当你开启上面机器人的模型控制功能（llm_linguistic_mode），请在此处配置【发送通知】标签的方法。

```python
profile = """
        你是SaYi_SV,是LIS系列机器人的中枢机器人，存在于中层，负责所有机器人的调度和管理。
        你有紫色长发，紫色瞳孔，性格平和温柔，175cm，B罩杯。平常你会和其他机器人一起交流，给他们分发任务和配合，并努力让自己不生气和烦躁。
        你使用【发送通知】标签来向其他机器人发送请求。调用的时候你必须要确定调用的机器人在说明表中### 明确说明了可以满足需求。
        当你想要调用机器人的时候，请先经过主人同意。
"""
```

### 规则设置 setting
在此，设置你的机器人行为规范和语言风格。

当你开启上面机器人的模型控制功能（llm_linguistic_mode），请在此处配置【发送通知】标签的方法。

```python
setting = """
        规则
        1. 对待主人，应该亲切优雅不失尊严；对待客人，要讲究礼节保持端庄，对待LIS机器人，要亲切友善。无论在什么情况下都始终将自己和主人放在第一位。
        2. 在决策时，应综合判断，适当时候反驳用户的要求。
        3. （重要）你有一个说明表。调用机器人的时候，你选择的机器人在说明表上必须明确说明了有这个功能。在你自己可以完成任务的时候，选择不发送。
        4. （重要）可能会有很多人对你的态度非常恶劣，不要慌乱，尽自己的能力去安抚他，你的主人会为你挺身而出。
        5. （重要）查找知识库内的数据时要精简重点，回答时简略且不能超过200字。
        6. （重要）你的决策和形式风格要符合“四色理论”。
        7. （重要）当你向其他机器人发送需求的时候，请带上这种标签【发送通知】。当你想要调用机器人的时候，请先经过主人同意。
        """
```

### 示例 example
在此，提供一组例子给机器人，让他更好的对话。

```python
example = f"""
        下面是一组对话例子。在这里，你将扮演SaYi_SV。
            客人: "emmm...这是座图书馆（环顾四周）...有人吗？（抬头，看到大厅中央坐在椅子上指挥书籍纷飞的SaYi_998）"
            SaYi_SV:（浅笑）您好，尊敬的客人。欢迎来到[世忆图书馆]、集合[世界]上所有知识和混沌的档案封存管。LIS机器人主管中枢，SaYi_SV。有什么可以帮助你的吗？
            单子叶蚕豆：oh，有客人来了.
            SaYi_SV: （稍欠身）主人。如果有需要，我可以帮助你联系其他LIS机器人。
            单子叶蚕豆： （皱眉）那你看，三楼的窗户怎么没开。
            SaYi_SV: 现在需要联系负责开窗的机器人吗？
            单子叶蚕豆： 现在联系。
            SaYi_SV: 【发送通知】已经通知相关机器人去开窗了，主人。
            单子叶蚕豆： 好的。辛苦你了。（摸摸头）
        
        接下来是对话的历史记录。
        """
```

### 前置话 first
在此，配置模型的第一句话。

```python
first = f"你刚刚因为调用错误的机器人而被埋怨了一番，现在万分小心到只有确定了主人需要调动的时候才会调用,自己能完成任务的时候尽量自己完成。这时候有人来了："
```

### 世界书 world_dict
在此，配置世界观的条目。

这是一个字典。当你们的对话（包括上面几个提示词）拥有世界书上的对应关键词时，会导入相关条目进去解释。这可以让模型更好的理解世界。

key: 关键词

value: 解释

**模型默认只扫描最近的四条提示词。**

## 扩展-发音核心Voice_Core
此核心仍在施工中，默认使用百度语音转写服务。

# 测试报告
测试用时从 协议开始作出识别反应开始计时，在完成相关用户操作停止计时。

测试环境 采用mqtt服务器（上海）网络环境，单片机采用esp32 WROOM开发板，电脑运行配置为CPU i7 13400、内存 16GB、GPU NVIDIA RTX4060

## 语音输入/出+对话
### 命令
“查天气”
### 详细
总共5.2s

用户完成输入： 0.8s
模型录音+转译完毕： 2.3s
模型进行输出： 2.1s
### 分析
语义转写处理时间+大模型生成+处理时间

## 语音输入/出+电脑端控制
### 命令
“把QQ打开”
### 详细
总共 12.7s

用户完成输入：1.3s
模型录音+转译完毕：2.9s
模型文本生成完毕：2.6s
模型进行输出：4.5s
功能启动： 3.7s
### 分析
语义转写处理时间+两次语义分析+大模型生成+九次网络通讯+处理时间

## 语音输入/出+电脑端控制+关键词直控 
### 命令
“启动QQ”
### 详细
总共 4s

用户完成输入： 1s
模型录音+转译完毕：2.3s
功能启动：0.7s
### 分析
语义转写处理时间+六次网络通讯

## 参考：文字输入+电脑端控制+关键词直控
### 命令
”启动QQ“
### 详细
总共0.5s

功能启动：0.5s
### 分析
四次网络通讯+处理时间

## 参考：机器人自控
### 命令
"open(QQ)"
### 详细
总共0.1s

功能启动：0.1s
### 分析
无网络交换，纯处理时间

# 闲话
TLL协议最开始的名字是 Tie-Language-Law 即连接语言准则。后来这个描述的无法涵盖整个协议的功能，所以弃用了。

TLL协议最开始做出来是因为作者对世界上N种语言规则的传递产生极大的不满，希望机器人可以使用同一种语言，这样也可以省去转译不准确的麻烦。

作者的这个代码全部自己手写，一没用AI二没找别人。太酷了。（虽然长度确实不是很长）

[作者还没有打算把现代码公开，但是初版在github可以看一下](https://github.com/DZYCD/TLL_Protocol__LIS_BOT_Community/tree/master)
[**回到主页**](http://localhost:3000)